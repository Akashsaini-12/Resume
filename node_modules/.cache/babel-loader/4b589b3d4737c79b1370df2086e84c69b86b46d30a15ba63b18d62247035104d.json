{"ast":null,"code":"var _jsxFileName = \"/Users/akashsaini/Desktop/Resume/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport Resume from './components/Resume';\nimport { jsPDF } from 'jspdf';\nimport html2canvas from 'html2canvas';\nimport './App.css';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [isGenerating, setIsGenerating] = useState(false);\n  const generatePDF = async () => {\n    setIsGenerating(true);\n    try {\n      const resumeContainer = document.getElementById('resume-container');\n      if (!resumeContainer) {\n        throw new Error('Resume container not found');\n      }\n\n      // Scroll to top to ensure we capture from the beginning\n      window.scrollTo(0, 0);\n\n      // Wait a bit for scroll to complete\n      await new Promise(resolve => setTimeout(resolve, 200));\n\n      // Get all sections\n      const sections = Array.from(resumeContainer.querySelectorAll('.resume-section'));\n      if (sections.length === 0) {\n        throw new Error('No sections found');\n      }\n\n      // Wait a bit more for layout to settle\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Get the inner content div (the actual resume content)\n      const resumeContent = resumeContainer.querySelector('.w-full');\n      if (!resumeContent) {\n        throw new Error('Resume content div not found');\n      }\n      const containerRect = resumeContainer.getBoundingClientRect();\n      const contentRect = resumeContent.getBoundingClientRect();\n\n      // Calculate section positions relative to the resume content div (not container)\n      // This is more accurate since sections are inside the content div\n      const sectionData = sections.map((section, idx) => {\n        const rect = section.getBoundingClientRect();\n        // Calculate position relative to content div's top\n        // Add the offset of content div within container\n        const contentOffsetTop = contentRect.top - containerRect.top;\n        const top = rect.top - contentRect.top + contentOffsetTop;\n        const bottom = rect.bottom - contentRect.top + contentOffsetTop;\n        return {\n          element: section,\n          top: Math.max(0, top),\n          bottom: Math.max(0, bottom),\n          height: rect.height,\n          index: idx,\n          sectionName: section.getAttribute('data-section') || `section-${idx}`\n        };\n      });\n\n      // Debug: Log section data\n      console.log('Sections found:', sectionData.length);\n      sectionData.forEach((s, i) => {\n        console.log(`Section ${i} (${s.sectionName}): top=${s.top.toFixed(2)}, bottom=${s.bottom.toFixed(2)}, height=${s.height.toFixed(2)}`);\n      });\n\n      // Ensure container is fully visible and scrolled to top\n      resumeContainer.scrollTop = 0;\n      window.scrollTo(0, 0);\n      await new Promise(resolve => setTimeout(resolve, 200));\n\n      // Get the actual content height - use the last section's bottom position\n      const lastSectionBottom = Math.max(...sectionData.map(s => s.bottom));\n      const containerFullHeight = Math.max(resumeContainer.scrollHeight, resumeContainer.offsetHeight, lastSectionBottom + 50 // Add some padding\n      );\n      console.log('Container heights:', {\n        scrollHeight: resumeContainer.scrollHeight,\n        offsetHeight: resumeContainer.offsetHeight,\n        lastSectionBottom: lastSectionBottom,\n        using: containerFullHeight\n      });\n      const canvas = await html2canvas(resumeContainer, {\n        scale: 2,\n        useCORS: true,\n        logging: false,\n        backgroundColor: '#ffffff',\n        width: resumeContainer.scrollWidth,\n        height: containerFullHeight,\n        windowWidth: resumeContainer.scrollWidth,\n        windowHeight: containerFullHeight,\n        allowTaint: false,\n        scrollX: 0,\n        scrollY: 0,\n        onclone: clonedDoc => {\n          // Ensure cloned document also has proper layout\n          const clonedContainer = clonedDoc.getElementById('resume-container');\n          if (clonedContainer) {\n            clonedContainer.style.overflow = 'visible';\n          }\n        }\n      });\n      console.log('Canvas captured:', canvas.width, 'x', canvas.height);\n      console.log('Expected height based on last section:', lastSectionBottom * 2);\n      const imgData = canvas.toDataURL('image/png', 1.0);\n\n      // Calculate PDF dimensions\n      const pdfWidth = 210; // A4 width in mm\n      const pdfHeight = 297; // A4 height in mm\n\n      // Calculate image dimensions to fit PDF width while maintaining aspect ratio\n      const imgWidth = pdfWidth;\n      const imgHeight = canvas.height * pdfWidth / canvas.width;\n\n      // Conversion factor: pixels to mm (for PDF)\n      const pixelsToMM = pdfWidth / canvas.width;\n\n      // Create PDF\n      const pdf = new jsPDF({\n        orientation: 'portrait',\n        unit: 'mm',\n        format: 'a4',\n        compress: true\n      });\n\n      // Convert pixel positions to PDF mm positions\n      const convertToPDFHeight = pixels => pixels * pixelsToMM;\n\n      // Group sections by page\n      const topMargin = 5;\n      const bottomMargin = 5;\n      const effectivePageHeight = pdfHeight - topMargin - bottomMargin;\n      let currentPageSections = [];\n      const pageGroups = [];\n      sectionData.forEach((section, index) => {\n        // Calculate the height needed if we add this section to current page\n        let pageStartY, pageEndY;\n        if (currentPageSections.length === 0) {\n          // First section on page\n          pageStartY = section.top;\n          pageEndY = section.bottom;\n        } else {\n          // Add to existing sections - use the first section's top and current section's bottom\n          pageStartY = currentPageSections[0].top;\n          pageEndY = section.bottom;\n        }\n        const pageHeightInPDF = convertToPDFHeight(pageEndY - pageStartY);\n        console.log(`Checking section ${section.sectionName}: pageHeight=${pageHeightInPDF.toFixed(2)}mm, effectiveHeight=${effectivePageHeight.toFixed(2)}mm`);\n\n        // Check if this section fits on current page\n        if (currentPageSections.length === 0 || pageHeightInPDF <= effectivePageHeight) {\n          currentPageSections.push(section);\n          console.log(`  -> Added to current page (${currentPageSections.length} sections)`);\n        } else {\n          // Current page is full, save it and start a new page\n          const lastPageGroup = {\n            sections: [...currentPageSections],\n            startY: currentPageSections[0].top,\n            endY: currentPageSections[currentPageSections.length - 1].bottom\n          };\n          pageGroups.push(lastPageGroup);\n          console.log(`  -> Page ${pageGroups.length} complete with ${lastPageGroup.sections.length} sections`);\n\n          // Start new page with current section\n          currentPageSections = [section];\n          console.log(`  -> Started new page with section ${section.sectionName}`);\n        }\n\n        // If this is the last section, add the current page group\n        if (index === sectionData.length - 1) {\n          const lastPageGroup = {\n            sections: [...currentPageSections],\n            startY: currentPageSections[0].top,\n            endY: currentPageSections[currentPageSections.length - 1].bottom\n          };\n          pageGroups.push(lastPageGroup);\n          console.log(`  -> Final page ${pageGroups.length} complete with ${lastPageGroup.sections.length} sections`);\n        }\n      });\n\n      // Calculate the actual scale factor between container and canvas\n      // html2canvas with scale: 2 means canvas should be 2x the size\n      // But we need to verify the actual scale\n      const containerHeight = containerFullHeight;\n      const containerToCanvasScaleY = canvas.height / containerHeight;\n      const containerToCanvasScaleX = canvas.width / resumeContainer.scrollWidth;\n      console.log('Scale calculation:', {\n        containerHeight,\n        canvasHeight: canvas.height,\n        scaleY: containerToCanvasScaleY,\n        scaleX: containerToCanvasScaleX,\n        expectedScale: 2,\n        actualScaleMatches: Math.abs(containerToCanvasScaleY - 2) < 0.1\n      });\n\n      // Verify all sections are within canvas bounds\n      const maxSectionBottom = Math.max(...sectionData.map(s => s.bottom));\n      const maxSectionBottomInCanvas = maxSectionBottom * containerToCanvasScaleY;\n      console.log('Section bounds check:', {\n        maxSectionBottom,\n        maxSectionBottomInCanvas,\n        canvasHeight: canvas.height,\n        withinBounds: maxSectionBottomInCanvas <= canvas.height\n      });\n      if (maxSectionBottomInCanvas > canvas.height) {\n        console.warn('WARNING: Some sections may be outside canvas bounds!');\n      }\n      console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);\n      console.log('Container scrollHeight:', resumeContainer.scrollHeight);\n      console.log('Container offsetHeight:', resumeContainer.offsetHeight);\n      console.log('Scale Y:', containerToCanvasScaleY);\n      console.log('Page groups:', pageGroups.length);\n      pageGroups.forEach((pg, i) => {\n        console.log(`Page ${i + 1} sections:`, pg.sections.map(s => s.sectionName).join(', '));\n      });\n\n      // Add pages based on section groups\n      pageGroups.forEach((pageGroup, groupIndex) => {\n        console.log(`\\n=== Processing page ${groupIndex + 1} ===`);\n        console.log('Sections:', pageGroup.sections.map(s => s.sectionName).join(', '));\n        console.log('Container Y range:', pageGroup.startY, 'to', pageGroup.endY);\n        if (groupIndex > 0) {\n          pdf.addPage();\n        }\n\n        // Convert pixel positions to canvas coordinates\n        // The positions are relative to container top, need to scale to canvas\n        const startYInCanvas = pageGroup.startY * containerToCanvasScaleY;\n        const endYInCanvas = pageGroup.endY * containerToCanvasScaleY;\n        const sectionHeightInCanvas = endYInCanvas - startYInCanvas;\n        console.log('Canvas Y range:', startYInCanvas.toFixed(2), 'to', endYInCanvas.toFixed(2));\n        console.log('Canvas height:', sectionHeightInCanvas.toFixed(2));\n\n        // Ensure we don't go beyond canvas bounds\n        const clampedStartY = Math.max(0, Math.floor(startYInCanvas));\n        const clampedEndY = Math.min(canvas.height, Math.ceil(endYInCanvas));\n        const clampedHeight = clampedEndY - clampedStartY;\n        console.log('Clamped Y range:', clampedStartY, 'to', clampedEndY);\n        console.log('Clamped height:', clampedHeight);\n        if (clampedHeight <= 0) {\n          console.error(`Page ${groupIndex + 1} has invalid height (${clampedHeight}), skipping`);\n          return;\n        }\n\n        // Create a temporary canvas to extract just this section\n        const sectionCanvas = document.createElement('canvas');\n        sectionCanvas.width = canvas.width;\n        sectionCanvas.height = clampedHeight;\n        const sectionCtx = sectionCanvas.getContext('2d');\n\n        // Fill with white background\n        sectionCtx.fillStyle = '#ffffff';\n        sectionCtx.fillRect(0, 0, sectionCanvas.width, sectionCanvas.height);\n\n        // Draw the relevant portion of the original canvas to the section canvas\n        try {\n          sectionCtx.drawImage(canvas, 0, clampedStartY,\n          // Source: x, y (from original canvas)\n          canvas.width, clampedHeight,\n          // Source: width, height\n          0, 0,\n          // Destination: x, y (to section canvas)\n          canvas.width, clampedHeight // Destination: width, height\n          );\n          console.log('Successfully extracted section to canvas');\n        } catch (error) {\n          console.error(`Error drawing image for page ${groupIndex + 1}:`, error);\n          return;\n        }\n\n        // Convert section canvas to image\n        const sectionImgData = sectionCanvas.toDataURL('image/png', 1.0);\n\n        // Calculate dimensions for PDF\n        const sectionWidthInPDF = pdfWidth;\n        const sectionHeightInPDF = sectionCanvas.height * pdfWidth / canvas.width;\n        console.log('PDF dimensions:', sectionWidthInPDF.toFixed(2), 'x', sectionHeightInPDF.toFixed(2), 'mm');\n\n        // Add the section image to the PDF\n        pdf.addImage(sectionImgData, 'PNG', 0, topMargin, sectionWidthInPDF, sectionHeightInPDF, undefined, 'FAST');\n        console.log(`Page ${groupIndex + 1} added to PDF`);\n      });\n      pdf.save('Akash-Saini-Resume.pdf');\n    } catch (error) {\n      console.error('Error generating PDF:', error);\n      alert('An error occurred while generating the PDF. Please try again.');\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app-container bg-gray-100 min-h-screen\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"fixed top-4 right-4 z-50 print:hidden\",\n      children: /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: generatePDF,\n        disabled: isGenerating,\n        className: `px-6 py-3 rounded-lg font-semibold text-white ${isGenerating ? 'bg-gray-500' : 'bg-[#2D3748] hover:bg-[#1a202c]'} transition-colors duration-200 shadow-lg flex items-center space-x-2`,\n        children: isGenerating ? /*#__PURE__*/_jsxDEV(_Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"animate-spin inline-block w-4 h-4 border-2 border-white border-t-transparent rounded-full mr-2\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 327,\n            columnNumber: 15\n          }, this), \"Generating PDF...\"]\n        }, void 0, true) : /*#__PURE__*/_jsxDEV(_Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"svg\", {\n            className: \"w-5 h-5 mr-2\",\n            fill: \"none\",\n            stroke: \"currentColor\",\n            viewBox: \"0 0 24 24\",\n            children: /*#__PURE__*/_jsxDEV(\"path\", {\n              strokeLinecap: \"round\",\n              strokeLinejoin: \"round\",\n              strokeWidth: 2,\n              d: \"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 333,\n              columnNumber: 17\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 332,\n            columnNumber: 15\n          }, this), \"Download Resume\"]\n        }, void 0, true)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 318,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 317,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"resume-container\",\n      className: \"max-w-[1200px] mx-auto my-8 bg-white shadow-xl print:shadow-none relative\",\n      children: /*#__PURE__*/_jsxDEV(Resume, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 342,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 341,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 316,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"UwcDqC7CmUDXsdKWKaG4uXzzAaQ=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","Resume","jsPDF","html2canvas","jsxDEV","_jsxDEV","Fragment","_Fragment","App","_s","isGenerating","setIsGenerating","generatePDF","resumeContainer","document","getElementById","Error","window","scrollTo","Promise","resolve","setTimeout","sections","Array","from","querySelectorAll","length","resumeContent","querySelector","containerRect","getBoundingClientRect","contentRect","sectionData","map","section","idx","rect","contentOffsetTop","top","bottom","element","Math","max","height","index","sectionName","getAttribute","console","log","forEach","s","i","toFixed","scrollTop","lastSectionBottom","containerFullHeight","scrollHeight","offsetHeight","using","canvas","scale","useCORS","logging","backgroundColor","width","scrollWidth","windowWidth","windowHeight","allowTaint","scrollX","scrollY","onclone","clonedDoc","clonedContainer","style","overflow","imgData","toDataURL","pdfWidth","pdfHeight","imgWidth","imgHeight","pixelsToMM","pdf","orientation","unit","format","compress","convertToPDFHeight","pixels","topMargin","bottomMargin","effectivePageHeight","currentPageSections","pageGroups","pageStartY","pageEndY","pageHeightInPDF","push","lastPageGroup","startY","endY","containerHeight","containerToCanvasScaleY","containerToCanvasScaleX","canvasHeight","scaleY","scaleX","expectedScale","actualScaleMatches","abs","maxSectionBottom","maxSectionBottomInCanvas","withinBounds","warn","pg","join","pageGroup","groupIndex","addPage","startYInCanvas","endYInCanvas","sectionHeightInCanvas","clampedStartY","floor","clampedEndY","min","ceil","clampedHeight","error","sectionCanvas","createElement","sectionCtx","getContext","fillStyle","fillRect","drawImage","sectionImgData","sectionWidthInPDF","sectionHeightInPDF","addImage","undefined","save","alert","className","children","onClick","disabled","fileName","_jsxFileName","lineNumber","columnNumber","fill","stroke","viewBox","strokeLinecap","strokeLinejoin","strokeWidth","d","id","_c","$RefreshReg$"],"sources":["/Users/akashsaini/Desktop/Resume/src/App.js"],"sourcesContent":["import React, { useState } from 'react';\nimport Resume from './components/Resume';\nimport { jsPDF } from 'jspdf';\nimport html2canvas from 'html2canvas';\nimport './App.css';\n\nfunction App() {\n  const [isGenerating, setIsGenerating] = useState(false);\n\n  const generatePDF = async () => {\n    setIsGenerating(true);\n\n    try {\n      const resumeContainer = document.getElementById('resume-container');\n      \n      if (!resumeContainer) {\n        throw new Error('Resume container not found');\n      }\n\n      // Scroll to top to ensure we capture from the beginning\n      window.scrollTo(0, 0);\n      \n      // Wait a bit for scroll to complete\n      await new Promise(resolve => setTimeout(resolve, 200));\n\n      // Get all sections\n      const sections = Array.from(resumeContainer.querySelectorAll('.resume-section'));\n      \n      if (sections.length === 0) {\n        throw new Error('No sections found');\n      }\n\n      // Wait a bit more for layout to settle\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Get the inner content div (the actual resume content)\n      const resumeContent = resumeContainer.querySelector('.w-full');\n      if (!resumeContent) {\n        throw new Error('Resume content div not found');\n      }\n      \n      const containerRect = resumeContainer.getBoundingClientRect();\n      const contentRect = resumeContent.getBoundingClientRect();\n      \n      // Calculate section positions relative to the resume content div (not container)\n      // This is more accurate since sections are inside the content div\n      const sectionData = sections.map((section, idx) => {\n        const rect = section.getBoundingClientRect();\n        // Calculate position relative to content div's top\n        // Add the offset of content div within container\n        const contentOffsetTop = contentRect.top - containerRect.top;\n        const top = (rect.top - contentRect.top) + contentOffsetTop;\n        const bottom = (rect.bottom - contentRect.top) + contentOffsetTop;\n        \n        return {\n          element: section,\n          top: Math.max(0, top),\n          bottom: Math.max(0, bottom),\n          height: rect.height,\n          index: idx,\n          sectionName: section.getAttribute('data-section') || `section-${idx}`\n        };\n      });\n\n      // Debug: Log section data\n      console.log('Sections found:', sectionData.length);\n      sectionData.forEach((s, i) => {\n        console.log(`Section ${i} (${s.sectionName}): top=${s.top.toFixed(2)}, bottom=${s.bottom.toFixed(2)}, height=${s.height.toFixed(2)}`);\n      });\n\n      // Ensure container is fully visible and scrolled to top\n      resumeContainer.scrollTop = 0;\n      window.scrollTo(0, 0);\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      // Get the actual content height - use the last section's bottom position\n      const lastSectionBottom = Math.max(...sectionData.map(s => s.bottom));\n      const containerFullHeight = Math.max(\n        resumeContainer.scrollHeight,\n        resumeContainer.offsetHeight,\n        lastSectionBottom + 50 // Add some padding\n      );\n      \n      console.log('Container heights:', {\n        scrollHeight: resumeContainer.scrollHeight,\n        offsetHeight: resumeContainer.offsetHeight,\n        lastSectionBottom: lastSectionBottom,\n        using: containerFullHeight\n      });\n      \n      const canvas = await html2canvas(resumeContainer, {\n        scale: 2,\n        useCORS: true,\n        logging: false,\n        backgroundColor: '#ffffff',\n        width: resumeContainer.scrollWidth,\n        height: containerFullHeight,\n        windowWidth: resumeContainer.scrollWidth,\n        windowHeight: containerFullHeight,\n        allowTaint: false,\n        scrollX: 0,\n        scrollY: 0,\n        onclone: (clonedDoc) => {\n          // Ensure cloned document also has proper layout\n          const clonedContainer = clonedDoc.getElementById('resume-container');\n          if (clonedContainer) {\n            clonedContainer.style.overflow = 'visible';\n          }\n        }\n      });\n      \n      console.log('Canvas captured:', canvas.width, 'x', canvas.height);\n      console.log('Expected height based on last section:', lastSectionBottom * 2);\n\n      const imgData = canvas.toDataURL('image/png', 1.0);\n      \n      // Calculate PDF dimensions\n      const pdfWidth = 210; // A4 width in mm\n      const pdfHeight = 297; // A4 height in mm\n      \n      // Calculate image dimensions to fit PDF width while maintaining aspect ratio\n      const imgWidth = pdfWidth;\n      const imgHeight = (canvas.height * pdfWidth) / canvas.width;\n      \n      // Conversion factor: pixels to mm (for PDF)\n      const pixelsToMM = pdfWidth / canvas.width;\n\n      // Create PDF\n      const pdf = new jsPDF({\n        orientation: 'portrait',\n        unit: 'mm',\n        format: 'a4',\n        compress: true\n      });\n\n      // Convert pixel positions to PDF mm positions\n      const convertToPDFHeight = (pixels) => pixels * pixelsToMM;\n      \n      // Group sections by page\n      const topMargin = 5;\n      const bottomMargin = 5;\n      const effectivePageHeight = pdfHeight - topMargin - bottomMargin;\n      \n      let currentPageSections = [];\n      const pageGroups = [];\n\n      sectionData.forEach((section, index) => {\n        // Calculate the height needed if we add this section to current page\n        let pageStartY, pageEndY;\n        \n        if (currentPageSections.length === 0) {\n          // First section on page\n          pageStartY = section.top;\n          pageEndY = section.bottom;\n        } else {\n          // Add to existing sections - use the first section's top and current section's bottom\n          pageStartY = currentPageSections[0].top;\n          pageEndY = section.bottom;\n        }\n        \n        const pageHeightInPDF = convertToPDFHeight(pageEndY - pageStartY);\n        \n        console.log(`Checking section ${section.sectionName}: pageHeight=${pageHeightInPDF.toFixed(2)}mm, effectiveHeight=${effectivePageHeight.toFixed(2)}mm`);\n        \n        // Check if this section fits on current page\n        if (currentPageSections.length === 0 || pageHeightInPDF <= effectivePageHeight) {\n          currentPageSections.push(section);\n          console.log(`  -> Added to current page (${currentPageSections.length} sections)`);\n        } else {\n          // Current page is full, save it and start a new page\n          const lastPageGroup = {\n            sections: [...currentPageSections],\n            startY: currentPageSections[0].top,\n            endY: currentPageSections[currentPageSections.length - 1].bottom\n          };\n          pageGroups.push(lastPageGroup);\n          console.log(`  -> Page ${pageGroups.length} complete with ${lastPageGroup.sections.length} sections`);\n          \n          // Start new page with current section\n          currentPageSections = [section];\n          console.log(`  -> Started new page with section ${section.sectionName}`);\n        }\n        \n        // If this is the last section, add the current page group\n        if (index === sectionData.length - 1) {\n          const lastPageGroup = {\n            sections: [...currentPageSections],\n            startY: currentPageSections[0].top,\n            endY: currentPageSections[currentPageSections.length - 1].bottom\n          };\n          pageGroups.push(lastPageGroup);\n          console.log(`  -> Final page ${pageGroups.length} complete with ${lastPageGroup.sections.length} sections`);\n        }\n      });\n\n      // Calculate the actual scale factor between container and canvas\n      // html2canvas with scale: 2 means canvas should be 2x the size\n      // But we need to verify the actual scale\n      const containerHeight = containerFullHeight;\n      const containerToCanvasScaleY = canvas.height / containerHeight;\n      const containerToCanvasScaleX = canvas.width / resumeContainer.scrollWidth;\n      \n      console.log('Scale calculation:', {\n        containerHeight,\n        canvasHeight: canvas.height,\n        scaleY: containerToCanvasScaleY,\n        scaleX: containerToCanvasScaleX,\n        expectedScale: 2,\n        actualScaleMatches: Math.abs(containerToCanvasScaleY - 2) < 0.1\n      });\n      \n      // Verify all sections are within canvas bounds\n      const maxSectionBottom = Math.max(...sectionData.map(s => s.bottom));\n      const maxSectionBottomInCanvas = maxSectionBottom * containerToCanvasScaleY;\n      console.log('Section bounds check:', {\n        maxSectionBottom,\n        maxSectionBottomInCanvas,\n        canvasHeight: canvas.height,\n        withinBounds: maxSectionBottomInCanvas <= canvas.height\n      });\n      \n      if (maxSectionBottomInCanvas > canvas.height) {\n        console.warn('WARNING: Some sections may be outside canvas bounds!');\n      }\n      \n      console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);\n      console.log('Container scrollHeight:', resumeContainer.scrollHeight);\n      console.log('Container offsetHeight:', resumeContainer.offsetHeight);\n      console.log('Scale Y:', containerToCanvasScaleY);\n      console.log('Page groups:', pageGroups.length);\n      pageGroups.forEach((pg, i) => {\n        console.log(`Page ${i + 1} sections:`, pg.sections.map(s => s.sectionName).join(', '));\n      });\n      \n      // Add pages based on section groups\n      pageGroups.forEach((pageGroup, groupIndex) => {\n        console.log(`\\n=== Processing page ${groupIndex + 1} ===`);\n        console.log('Sections:', pageGroup.sections.map(s => s.sectionName).join(', '));\n        console.log('Container Y range:', pageGroup.startY, 'to', pageGroup.endY);\n\n        if (groupIndex > 0) {\n          pdf.addPage();\n        }\n\n        // Convert pixel positions to canvas coordinates\n        // The positions are relative to container top, need to scale to canvas\n        const startYInCanvas = pageGroup.startY * containerToCanvasScaleY;\n        const endYInCanvas = pageGroup.endY * containerToCanvasScaleY;\n        const sectionHeightInCanvas = endYInCanvas - startYInCanvas;\n        \n        console.log('Canvas Y range:', startYInCanvas.toFixed(2), 'to', endYInCanvas.toFixed(2));\n        console.log('Canvas height:', sectionHeightInCanvas.toFixed(2));\n        \n        // Ensure we don't go beyond canvas bounds\n        const clampedStartY = Math.max(0, Math.floor(startYInCanvas));\n        const clampedEndY = Math.min(canvas.height, Math.ceil(endYInCanvas));\n        const clampedHeight = clampedEndY - clampedStartY;\n        \n        console.log('Clamped Y range:', clampedStartY, 'to', clampedEndY);\n        console.log('Clamped height:', clampedHeight);\n        \n        if (clampedHeight <= 0) {\n          console.error(`Page ${groupIndex + 1} has invalid height (${clampedHeight}), skipping`);\n          return;\n        }\n        \n        // Create a temporary canvas to extract just this section\n        const sectionCanvas = document.createElement('canvas');\n        sectionCanvas.width = canvas.width;\n        sectionCanvas.height = clampedHeight;\n        const sectionCtx = sectionCanvas.getContext('2d');\n        \n        // Fill with white background\n        sectionCtx.fillStyle = '#ffffff';\n        sectionCtx.fillRect(0, 0, sectionCanvas.width, sectionCanvas.height);\n        \n        // Draw the relevant portion of the original canvas to the section canvas\n        try {\n          sectionCtx.drawImage(\n            canvas,\n            0, clampedStartY, // Source: x, y (from original canvas)\n            canvas.width, clampedHeight, // Source: width, height\n            0, 0, // Destination: x, y (to section canvas)\n            canvas.width, clampedHeight // Destination: width, height\n          );\n          console.log('Successfully extracted section to canvas');\n        } catch (error) {\n          console.error(`Error drawing image for page ${groupIndex + 1}:`, error);\n          return;\n        }\n        \n        // Convert section canvas to image\n        const sectionImgData = sectionCanvas.toDataURL('image/png', 1.0);\n        \n        // Calculate dimensions for PDF\n        const sectionWidthInPDF = pdfWidth;\n        const sectionHeightInPDF = (sectionCanvas.height * pdfWidth) / canvas.width;\n        \n        console.log('PDF dimensions:', sectionWidthInPDF.toFixed(2), 'x', sectionHeightInPDF.toFixed(2), 'mm');\n        \n        // Add the section image to the PDF\n        pdf.addImage(sectionImgData, 'PNG', 0, topMargin, sectionWidthInPDF, sectionHeightInPDF, undefined, 'FAST');\n        console.log(`Page ${groupIndex + 1} added to PDF`);\n      });\n      \n      pdf.save('Akash-Saini-Resume.pdf');\n    } catch (error) {\n      console.error('Error generating PDF:', error);\n      alert('An error occurred while generating the PDF. Please try again.');\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  return (\n    <div className=\"app-container bg-gray-100 min-h-screen\">\n      <div className=\"fixed top-4 right-4 z-50 print:hidden\">\n        <button\n          onClick={generatePDF}\n          disabled={isGenerating}\n          className={`px-6 py-3 rounded-lg font-semibold text-white ${\n            isGenerating ? 'bg-gray-500' : 'bg-[#2D3748] hover:bg-[#1a202c]'\n          } transition-colors duration-200 shadow-lg flex items-center space-x-2`}\n        >\n          {isGenerating ? (\n            <>\n              <span className=\"animate-spin inline-block w-4 h-4 border-2 border-white border-t-transparent rounded-full mr-2\" />\n              Generating PDF...\n            </>\n          ) : (\n            <>\n              <svg className=\"w-5 h-5 mr-2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4\" />\n              </svg>\n              Download Resume\n            </>\n          )}\n        </button>\n      </div>\n\n      <div id=\"resume-container\" className=\"max-w-[1200px] mx-auto my-8 bg-white shadow-xl print:shadow-none relative\">\n        <Resume />\n      </div>\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}